#!/usr/bin/perl
# recursively submits jobs tracking dependencies to GridEngine
# Copyright (C) 2009-2010 Henning Glawe <glaweh@debian.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

use strict;
use warnings;
use Getopt::Long;
use Cwd;
use File::Spec;

my $dryrun=0;
my $recurse_dir='';
my $qsub_global_opts = '';
my $MAX_RECURSIONS=20;

sub submit_one {
	my ($script,$options,$recursion_level)=@_;
	if ($recursion_level > $MAX_RECURSIONS) {
		print "too many recursions: $recursion_level > $MAX_RECURSIONS\n";
		return 4223;
	}
	if (-s $script) {
		my $jobidfile="$script.submitted";
		if (! -s $jobidfile) {
			$script=~/^(.*\/)([^\/]+)$/;
			my ($dir,$script_base)=($1,$2);
			my $olddir=getcwd;
			chdir $dir;
			my $jobidfile="$script_base.submitted";

			my $dep_option='';
			my $dep_glob_file="$script_base.depends";
			if (-s $dep_glob_file) {
				my $dep_glob_fh;
				my @dep_files;
				my @dep_ids;
				my $n_patterns=0;
				open($dep_glob_fh,$dep_glob_file);
				while (<$dep_glob_fh>) {
					chomp;
					s/#.*//;
					next if (/^\s*$/);
					$n_patterns++;
					push @dep_files,glob;
				}
				close($dep_glob_fh);
				if ($n_patterns and (@dep_files < 1)) {
					print "not submitting: $script_base.depends exists, but no matching files found\n";
					chdir $olddir;
					return 4242;
				}
				foreach my $dep (@dep_files) {
					next if (-f "$dep.completed");
					my $dep_id;
					if (! -s "$dep.submitted") {
						my $retval=submit_one($dep,$options,$recursion_level+1);
						$dep_id=(1000000-$recursion_level) if ($dryrun and $retval==0);
						if ($retval != 0) {
							print "error submitting dependency job\n";
							chdir $olddir;
							return 4243;
						}
					}
					if ((! defined $dep_id) and (-s "$dep.submitted")) {
						my $dep_fh;
						open($dep_fh,"$dep.submitted");
						$_=<$dep_fh>;
						chomp;
						$dep_id=$_ unless (/^\s*$/);
						close($dep_fh);
					}
					push @dep_ids,$dep_id if (defined $dep_id);
				}
				if (@dep_ids) {
					$dep_option='-hold_jid ' . join(',',@dep_ids);
				}
			}

			my $qsub_cmd="qsub $options $dep_option $script_base";
			if ($dryrun) {
				print STDERR "dryrun: would run '$qsub_cmd'\n";
				chdir $olddir;
				return(0);
			}

			my $resultstring=`$qsub_cmd`;
			my $qsubret=$?;

			if (($qsubret == 0) and ($resultstring=~/^Your job ([0-9]+) .*/)) {
				open(my $fh,">$jobidfile");
				print $fh "$1\n";
				close($fh);
				print "Job $1 submitted\n";
				# create backref, as the script name is usually not available at runtime
				open($fh,">$1.script");
				print $fh "$script_base\n";
				close($fh);
				chdir $olddir;
				return($qsubret);
			} else {
				print 'Problem submitting job: ' . (defined $resultstring ? $resultstring : 'result empty') . "\n";
				chdir $olddir;
				return(4200);
			}
			chdir $olddir;
		} else {
			print "$script already submitted\n";
			return(0);
		}
	} else {
		print "Cannot run $script: no such file or directory!\n";
		return(4201);
	}
}

GetOptions('recurse_dir|D=s' => \$recurse_dir, 'qsub_opts|O=s' => \$qsub_global_opts, 'dryrun|n' => \$dryrun);
die "No scriptname" if (@ARGV < 1);

my @scripts;
if ($recurse_dir) {
	foreach my $tmpl (@ARGV) {
		die "directory '$recurse_dir' does not exist" unless (-d $recurse_dir);
		if ($tmpl =~ /\//) {
			die "No '/' in filenames when recursing, please!\n";
		} else {
			open(my $find,"find $recurse_dir -type f -name $tmpl -! -path \*/trash/\* -! -path \*/backup/\*|");
			push @scripts,map { chomp; $_ } <$find>;
			close($find);
		}
	}
} else {
	@scripts=@ARGV;
}
@scripts=map { File::Spec->rel2abs($_) } @scripts;

foreach my $script (@scripts) {
	print "script: $script\n";
	submit_one($script,$qsub_global_opts,0);
}

